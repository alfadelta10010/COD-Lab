# Program 1: 
### Statement: Convert a 32-bit value from Little Endian to Big Endian format using RISC-V assembly

### Name of file:
endian_conversion.s

### Observation - Explanation
- The 32-bit value is loaded from memory
- The 32-bit value is ANDed with 0xFF and shifted right (logically) by 8 bits
- This is repeated until all 4 bytes of the word have been ANDed
- The resultant values are then stored back into memory in Big Endian format

### Observation - Single Cycle
- **Cycles:** 15
- **Frequency:** 9.43 Hz
- **CPI:** 1
- **IPC:** 1

### Observation - 5 Stage
- **Cycles:** 20
- **Frequency:** 10.20 Hz
- **CPI:** 1.33
- **IPC:** 0.75

### Memory Mapping
- **0x10000000:** 0x12345678
- **0x10000004:** 0x78563412

### Register Mapping
- **x5:** 0x00000012
- **x6:** 0x00000078
- **x7:** 0x00000056
- **x8:** 0x00000034
- **x9:** 0x00000012
- **x10:** 0x10000000
- **x11:** 0x12345678

### Snapshot
![Screenshot of RIPES window](<endian_conversion.png>)


# Program 2: 
### Statement: Write an Assembly Program for addition of 2 64-bit numbers on RV32I

### Name of file:
64bit_carry.s

### Observation - Single Cycle
- Four "lw" operations are used to load two 64-bit numbers
- Addition is performed on the 16 least significant bits of the numbers, and sltu is used to check if a carry was generated
- The same is repeated with the 16 most significant bits of the numbers
- The carry generated from the LSBs is then added to the result of the MSB addition
- Since a carry can be generated while adding the LSB carry or while adding the 16 MSBs, sltu is used twice to check for carries, and the results are ORed to obtain the final carry value
- Three "lw" operations are used to store the 64 bit result and the carry

### Observation - Single Cycle
- **Cycles:** 16
- **Frequency:** 9.71 Hz
- **CPI:** 1
- **IPC:** 1

### Observation - 5 Stage
- **Cycles:** 21
- **Frequency:** 10.87 Hz
- **CPI:** 1.31
- **IPC:** 0.762
 
### Register Mapping
- **x5:** 0x00000001 (Carry generated by addition of 16 least significant bits)
- **x6:** 0xfffffffe (Result of addition of 16 most significant bits)
- **x11:** 0xffffffff (Next four registers contain the 64 bit numbers)
- **x12:** 0xffffffff
- **x13:** 0xffffffff
- **x13:** 0xffffffff
- **x14:** 0xfffffffe (Result of addition of 16 least significant bits, next three registers contain the result)
- **x15:** 0xffffffff (Result of addition of x5 and x6)
- **x15:** 0x00000001 (Final carry value)

### Data Mapping
- **0x10000000:** 0xffffffff 
- **0x10000004:** 0xffffffff 
- **0x10000008:** 0xffffffff 
- **0x1000000c:** 0xffffffff 
- **0x10000010:** 0xfffffffe
- **0x10000014:** 0xffffffff 
- **0x10000018:** 0x00000001

### Snapshot
![Screenshot of RIPES window](<64bit_carry.png>)
